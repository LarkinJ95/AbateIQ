
{
  "entities": {
    "Org": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Organization",
      "type": "object",
      "description": "Represents a company or organization using the AbateIQ platform.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the organization."
        },
        "name": {
          "type": "string",
          "description": "Name of the organization."
        },
        "createdAt": {
          "type": "string",
          "description": "Date of organization creation.",
          "format": "date-time"
        }
      },
      "required": ["id", "name"]
    },
    "Client": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Client",
      "type": "object",
      "description": "Represents a client of an AbateIQ organization.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the client."
        },
        "name": {
          "type": "string",
          "description": "Name of the client."
        },
        "contactEmail": {
          "type": "string",
          "description": "Contact email address for the client.",
          "format": "email"
        }
      },
      "required": ["id", "name"]
    },
    "Project": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Project",
      "type": "object",
      "description": "Represents a project associated with a client.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the project."
        },
        "clientId": {
          "type": "string",
          "description": "Reference to Client. (Relationship: Client 1:N Project)"
        },
        "name": {
          "type": "string",
          "description": "Name of the project."
        },
        "description": {
          "type": "string",
          "description": "Description of the project."
        }
      },
      "required": ["id", "clientId", "name"]
    },
    "Personnel": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Personnel",
      "type": "object",
      "description": "Represents a person working on a project.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the personnel."
        },
        "name": {
          "type": "string",
          "description": "Name of the person."
        }
      },
      "required": ["id", "name"]
    },
    "Sample": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Sample",
      "type": "object",
      "description": "Represents a sample taken for analysis.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the sample."
        },
        "projectId": {
          "type": "string",
          "description": "Reference to Project. (Relationship: Project 1:N Sample)"
        },
        "personnelId": {
          "type": "string",
          "description": "Reference to Personnel. (Relationship: Personnel 1:N Sample)"
        }
      },
      "required": ["id", "projectId", "personnelId"]
    }
  },
  "auth": {
    "providers": ["password", "anonymous"],
    "customClaims": ["orgId", "role"]
  },
  "firestore": {
    "rules": "rules_version = '2';\nservice cloud.firestore {\n  match /databases/{db}/documents {\n    function authed() { return request.auth != null; }\n    function hasOrg(org) { return authed() && request.auth.token.orgId == org; }\n    function roleIs(r) { return authed() && request.auth.token.role == r; }\n    // Everything org-scoped lives under /orgs/{orgId}/...\n    match /orgs/{orgId}/{document=**} {\n      allow read: if hasOrg(orgId);\n      allow create, update: if hasOrg(orgId) && (roleIs('admin') || roleIs('editor'));\n      allow delete: if hasOrg(orgId) && roleIs('admin');\n    }\n  }\n}",
    "structure": [
      {
        "path": "/orgs/{orgId}",
        "definition": {
          "entityName": "Org",
          "schema": { "$ref": "#/entities/Org" },
          "description": "Stores organization information."
        }
      },
      {
        "path": "/orgs/{orgId}/clients/{clientId}",
        "definition": {
          "entityName": "Client",
          "schema": { "$ref": "#/entities/Client" },
          "description": "Stores client information for an organization."
        }
      },
      {
        "path": "/orgs/{orgId}/projects/{projectId}",
        "definition": {
          "entityName": "Project",
          "schema": { "$ref": "#/entities/Project" },
          "description": "Stores project information for an organization."
        }
      },
      {
        "path": "/orgs/{orgId}/personnel/{personnelId}",
        "definition": {
          "entityName": "Personnel",
          "schema": { "$ref": "#/entities/Personnel" },
          "description": "Stores personnel information for an organization."
        }
      },
      {
        "path": "/orgs/{orgId}/samples/{sampleId}",
        "definition": {
          "entityName": "Sample",
          "schema": { "$ref": "#/entities/Sample" },
          "description": "Stores sample information for an organization."
        }
      }
    ],
    "reasoning": "The Firestore structure is designed around a multi-tenant, organization-scoped model. All primary data collections (clients, projects, personnel, samples, etc.) are nested under a top-level `/orgs/{orgId}` collection. This structural nesting directly maps to the Firestore security rules, which use the `orgId` from a user's custom claims to grant access only to documents within their own organization's data tree. This provides strong data isolation between tenants. The security rules implement role-based access control (RBAC), granting read access to all authenticated users within an organization, while write access (create, update, delete) is restricted to users with 'admin' or 'editor' roles, ensuring data integrity."
  }
}
